diff --git a/dist/shared/rollup.js b/dist/shared/rollup.js
index b351dd9f79e32c7e3111a76b6000e18317f1e166..14aab84132ba3f57b528ad4bb5cdcce1f7091145 100644
--- a/dist/shared/rollup.js
+++ b/dist/shared/rollup.js
@@ -1862,7 +1862,7 @@ let Chunk$1 = class Chunk {
 			// '  test'.trim()
 			//     split   -> '  ' + 'test'
 			//   ✔️ edit    -> '' + 'test'
-			//   ✖️ edit    -> 'test' + '' 
+			//   ✖️ edit    -> 'test' + ''
 			// TODO is this block necessary?...
 			newChunk.edit('', false);
 			this.content = '';
@@ -6431,7 +6431,7 @@ const limitConcatenatedPathDepth = (path1, path2) => {
 };
 
 class LocalVariable extends Variable {
-    constructor(name, declarator, init, 
+    constructor(name, declarator, init,
     /** if this is non-empty, the actual init is this path of this.init */
     initPath, context, kind) {
         super(name);
@@ -7855,7 +7855,7 @@ class ExpressionStatement extends NodeBase {
         if (this.directive &&
             this.directive !== 'use strict' &&
             this.parent.type === parseAst_js.Program) {
-            this.scope.context.log(parseAst_js.LOGLEVEL_WARN, 
+            this.scope.context.log(parseAst_js.LOGLEVEL_WARN,
             // This is necessary, because either way (deleting or not) can lead to errors.
             parseAst_js.logModuleLevelDirective(this.directive, this.scope.context.module.id), this.start);
         }
@@ -8747,6 +8747,7 @@ class MemberExpression extends NodeBase {
         init.deoptimizePath([...destructuredInitPath, UnknownKey]);
     }
     deoptimizeCache() {
+        if (this.propertyKey === this.dynamicPropertyKey) return;
         const { expressionsToBeDeoptimized, object } = this;
         this.expressionsToBeDeoptimized = parseAst_js.EMPTY_ARRAY;
         this.dynamicPropertyKey = this.propertyKey;
@@ -8783,7 +8784,7 @@ class MemberExpression extends NodeBase {
         }
         const propertyKey = this.getDynamicPropertyKey();
         if (propertyKey !== UnknownKey && path.length < MAX_PATH_DEPTH) {
-            this.expressionsToBeDeoptimized.push(origin);
+            if (propertyKey !== this.propertyKey) this.expressionsToBeDeoptimized.push(origin);
             return this.object.getLiteralValueAtPath([propertyKey, ...path], recursionTracker, origin);
         }
         return UnknownValue;
@@ -8806,7 +8807,7 @@ class MemberExpression extends NodeBase {
         }
         const propertyKey = this.getDynamicPropertyKey();
         if (propertyKey !== UnknownKey && path.length < MAX_PATH_DEPTH) {
-            this.expressionsToBeDeoptimized.push(origin);
+            if (propertyKey !== this.propertyKey) this.expressionsToBeDeoptimized.push(origin);
             return this.object.getReturnExpressionWhenCalledAtPath([propertyKey, ...path], interaction, recursionTracker, origin);
         }
         return UNKNOWN_RETURN_EXPRESSION;
@@ -8998,7 +8999,7 @@ class MemberExpression extends NodeBase {
     }
     getDynamicPropertyKey() {
         if (this.dynamicPropertyKey === null) {
-            this.dynamicPropertyKey = UnknownKey;
+            this.dynamicPropertyKey = this.propertyKey;
             const value = this.property.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
             return (this.dynamicPropertyKey =
                 value === SymbolToStringTag
@@ -10642,7 +10643,7 @@ function requireUtils () {
 		  }
 
 		  return last;
-		}; 
+		};
 	} (utils));
 	return utils;
 }
@@ -18537,7 +18538,7 @@ class Module {
             if (module.info.syntheticNamedExports === name) {
                 continue;
             }
-            const [variable, indirectExternal] = getVariableForExportNameRecursive(module, name, importerForSideEffects, true, 
+            const [variable, indirectExternal] = getVariableForExportNameRecursive(module, name, importerForSideEffects, true,
             // We are creating a copy to handle the case where the same binding is
             // imported through different namespace reexports gracefully
             copyNameToModulesMap(searchedNamesAndModules));
@@ -19143,7 +19144,7 @@ class Chunk {
             }
         }
         for (const module of entryModules) {
-            const requiredFacades = Array.from(new Set(module.chunkNames.filter(({ isUserDefined }) => isUserDefined).map(({ name }) => name)), 
+            const requiredFacades = Array.from(new Set(module.chunkNames.filter(({ isUserDefined }) => isUserDefined).map(({ name }) => name)),
             // mapping must run after Set 'name' dedupe
             name => ({
                 name
@@ -20558,7 +20559,7 @@ function compareChunkSize({ size: sizeA }, { size: sizeB }) {
 function mergeChunks(chunkPartition, minChunkSize, sideEffectAtoms, sizeByAtom) {
     const { small } = chunkPartition;
     for (const mergedChunk of small) {
-        const bestTargetChunk = findBestMergeTarget(mergedChunk, chunkPartition, sideEffectAtoms, sizeByAtom, 
+        const bestTargetChunk = findBestMergeTarget(mergedChunk, chunkPartition, sideEffectAtoms, sizeByAtom,
         // In the default case, we do not accept size increases
         minChunkSize <= 1 ? 1 : Infinity);
         if (bestTargetChunk) {
@@ -20614,7 +20615,7 @@ function findBestMergeTarget(mergedChunk, { big, small }, sideEffectAtoms, sizeB
  * Merging will not produce cycles if none of the direct non-merged
  * dependencies of a chunk have the other chunk as a transitive dependency.
  */
-function getAdditionalSizeAfterMerge(mergedChunk, targetChunk, 
+function getAdditionalSizeAfterMerge(mergedChunk, targetChunk,
 // The maximum additional unused code size allowed to be added by the merge,
 // taking dependencies into account, needs to be below this number
 currentAdditionalSize, sideEffectAtoms, sizeByAtom) {
